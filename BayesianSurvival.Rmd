---
title: "BayesianSurvival"
author: "Yufang"
date: "2025-02-19"
output: pdf_document
---

# STEP 1. load packages
```{r, echo=TRUE}
rm(list = ls())
# install.packages("rstan")
# install.packages("readr")
library(rstan)
library(readr)
library(survival)
library(splines2)
# Set seed for reproducibility
set.seed(42)
source("./SurvivalDataGenerator.R")
```

# STEP 2. predefine a design matrix with one column 
```{r, echo=TRUE}
n_samples = 1000
Betas = 1
Design_matrix = as.matrix(rbinom(n_samples, 1, prob = 0.5)) #rnorm(n_samples))
BaselinePara = c(0.1, 0.2)


stan_data = SurvivalDataGenerator(n_samples, Betas, Design_matrix, 
                                  BaselinePara, BaselineDistr = "weibull") # exponential, weibull, and Gompertz

# use the traditional coxph to verify that the data was correctly generated
coxph(Surv(stan_data$obstime, stan_data$status) ~ stan_data$covariate)
```
## Conclusion for STEP 2: the betas are correctly estimated via traditional cox regression, meaning that data was correctly generated.

# STEP 3. Semiparametric & Parametric Bayesian survival model
```{r, echo=TRUE}
Bayesian_Survival_PH <- function(stan_data,
                              niter = 10000,
                              nwarmup = 1000,
                              thin = 10,
                              chains = 1) {
  # Proportional Hazard (PH) Model with covariates via partial likelihood function
  code_bayesian_model <- "
    data {
      int <lower=0> K; //num covariates
      int <lower=0> N; // num uncensored obs

      matrix[N, K] x; // covariates for uncensored obs

      int N_cens; // num censored obs
      matrix[N_cens, K] x_cens; // covariates for censored obs
  }
  parameters {
    vector[K] beta; // slopes without intercept
  }
  model {
    beta ~ normal(0, 2); // prior
    vector[N] log_theta = x * beta;
    vector [N_cens] log_theta_c = x_cens * beta;
    real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
    target += log_theta - log_denom;

  }
"
  
  
  # compile the model
  bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
  
  # Model fitting and summary
  bayesian_model_fit <- suppressWarnings(
    sampling(
      bayesian_model,
      data = stan_data,
      iter = niter,
      warmup = nwarmup,
      thin = 10,
      chain = 1
    )
  )
  
  # Summary of the fit
  output <- summary(bayesian_model_fit)$summary
  return(output)
  
}

Output <- Bayesian_Survival_PH(stan_data = stan_data) # The weibull and Gompertz simulation was not correctly implemented yet.
print(Output)
```
## Conclusion for STEP 3: the betas are correctly estimated via bayesian cox regression, meaning that bayesian cox regression was correctly defined.

## STEP 4.1: estimate the baseline function
```{r, echo=TRUE}
# Exponential baseline distribution from a bayesian perspective
Bayesian_Survival_baseline <- function(stan_data_basline, assumption = "exponential", school = "Bayesian", 
                              niter = 10000, 
                              nwarmup = 1000,
                              thin = 10,
                              chains = 1) {
  if (school == "Bayesian") {
    if (assumption == "exponential") {
      code_bayesian_model <- "
    data {
      int <lower=0> K; //num covariates
      int <lower=0> N; // num uncensored obs

      vector[N] t; // event time (non-strict decreasing)
      matrix[N, K] x; // covariates for uncensored obs

      int N_cens; // num censored obs
      vector[N_cens] t_cens; // censoring time
      matrix[N_cens, K] x_cens; // covariates for censored obs

      vector[K] Beta; // estimated coefficients from PH model
    }

    parameters {
    real<lower = 0> lambda; // parameters in expoential assumption
    }
    model {
    // prior
    lambda ~ lognormal(0, 1);

    // log-likelihood, represented by [target]

    target += exponential_lpdf(t | lambda * exp(x*Beta)); // uncensored data log(f(t))

    target += exponential_lccdf(t_cens | lambda * exp(x*Beta)); // right censored data log(S(t))
    }
    "
    }
    
    else if (assumption == "weibull") {
      code_bayesian_model <- "
      data {
        int <lower=0> K; //num covariates
        int <lower=0> N; // num uncensored obs

        vector[N] t; // event time (non-strict decreasing)
        matrix[N, K] x; // covariates for uncensored obs

        int N_cens; // num censored obs
        vector[N_cens] t_cens; // censoring time
        matrix[N_cens, K] x_cens; // covariates for censored obs

        vector[K] Beta; // estimated coefficients from PH model
      }
      parameters {
        real<lower = 0> alpha; // parameters in weibull assumption
        real<lower = 0> sigma; // parameters in weibull assumption
       }
     model {
       // Priors
       alpha ~ lognormal(0, 1);
       sigma ~ lognormal(0, 1);

       // log-likelihood, represented by [target]
       target += weibull_lpdf(t | alpha, sigma/exp(x*Beta/alpha)); // weibull_lpdf() is at log scale // uncensored data log(f(t))
       target += weibull_lccdf(t_cens | alpha, sigma/exp(x_cens*Beta/alpha)); // weibull_lccdf() is at log scale  // right censored data log(S(t)) //log complementary cumulative distribution function (log-CCDF) for an weibull distribution
  }
"
    }
    
    else if (assumption == "bSplines") {
      message("We utilized B-splines to estimate the baseline cumulative hazard function.")
      time_combined <- sort(unique(c(stan_data_basline$t, stan_data_basline$t_cens)))
      time_cens <- sort(unique(stan_data_basline$t_cens))
      time_ <- sort(unique(stan_data_basline$t))
      notes = seq(runif(5, min(time_combined), max(time_combined)))
      bSpline_basis <- bSpline(time_combined, knots = notes, degree = 3, intercept = FALSE) # The B-spline basis is calculated using the method implemented in the splines2 package
      
      # Find indices of time_cens and time in time_combined
      indices_time_cens <- match(time_cens, time_combined)
      indices_time <- match(time_, time_combined)
      
      # Select rows from bSpline_basis corresponding to time_cens and time_
      bSpline_basis_time_cens <- bSpline_basis[indices_time_cens, ]
      bSpline_basis_time <- bSpline_basis[indices_time, ]
      
      # Out the corresponding information in stan data
      stan_data_basline$bSpline_basis_t <- bSpline_basis_time
      stan_data_basline$bSpline_basis_t_cens <- bSpline_basis_time_cens
      stan_data_basline$M = length(time_combined)
      stan_data_basline$uniqueT = time_combined
      stan_data_basline$O = length(time_)
      stan_data_basline$uniquet = time_
      stan_data_basline$Q = length(time_cens)
      stan_data_basline$uniquet_cens = time_cens
      
      code_bayesian_model <- "
      functions {
        real gauss_kronrod_quad(real[] locat, real[] weights, real Ti, vector T, matrix bSpline_basis, vector coefficients, matrix x, vector beta){
          real integral_ = 0;
          real integral = 0;
          real u; 
          for (q in 1:num_elements(locat)){
            u = Ti * (1 + locat[q])/2;
            integral_ += weights[q] * h_i(u, T, bSpline_basis, coefficients, x, beta);
          }
          integral = integral_/2;
          return (integral);
        }
        
        real h_i(real u, vector T, matrix bSpline_basis, vector coefficients, matrix x, vector beta){
           // define the hazard function
           int index;
           vector[num_elements(T)] h_t;
           
           real h_i = 0;
           print(u);
           index = find_index(u, T);
           print(index);
           
           h_t = (bSpline_basis * coefficients) .* (x * beta);
           h_i = h_t[index];
           
           return h_i;
        }
        
      int is_in_vector(real u, vector t){
        for (i in 1:num_elements(t)){
          if (u == t[i]){
            return 1; // Returen 1 if u is found in t
          }
        }
       return 0; // Return 0 if u is not found in t
      }
      
     int find_index(real u, vector t) {
       for (i in 1:num_elements(t)) {
          if (u == t[i]) {
            return i; // Return the index if u is found in t
          }
       }
       return -1; //Return -1 if u is not found in t
     }
      }
      
      data {
        int <lower=0> K; //num covariates
        int <lower=0> N; // num uncensored obs
        int <lower=0> M; // num unique time points
        int <lower=0> O; // num unqiue time points in t
        int <lower=0> Q; // num unqiue time points in t_cens
        

        vector[N] t; // event time (non-strict decreasing)
        matrix[N, K] x; // covariates for uncensored obs

        int N_cens; // num censored obs
        vector[N_cens] t_cens; // censoring time
        matrix[N_cens, K] x_cens; // covariates for censored obs

        vector[K] Beta; // estimated coefficients from PH model
        
        matrix[N, 8] bSpline_basis_t;
        matrix[N_cens, 8] bSpline_basis_t_cens;
        vector[M] uniqueT; //montously increasing unique time points
        vector[O] uniquet; //montously increasing unique time points for t
        vector[Q] uniquet_cens; //montously increasing unique time points for t_cens
      }
      
      parameters {
        vector[8] coefficients;
      } 
        
      model {
        real locat[15] = {-0.991455, -0.949107, -0.864865, -0.741531, -0.586087, -0.405845, -0.207785, 0.0, 0.207785, 0.405845, 0.586087, 0.741531, 0.864865, 0.949107, 0.991455};
        real weights[15] = {0.022935, 0.063093, 0.104790, 0.140653, 0.169004, 0.190350, 0.204432, 0.209482, 0.204432, 0.190350, 0.169004, 0.140653, 0.104790, 0.063093, 0.022935};
        
      // Priors
        coefficients ~ normal(0, 1);
      
      // log-likelihood, represented by [target]
      for (Ti in uniqueT){
        if (find_index(Ti, uniquet) != -1) {
         print(999);
         print(Ti);
         print(find_index(Ti, uniquet));
         print(888);
         target += -gauss_kronrod_quad(locat, weights, Ti, uniquet, bSpline_basis_t, coefficients, x, Beta);// + h_i(Ti, uniquet, bSpline_basis_t, coefficients, x, Beta); // uncensored data log(f(t)) = -H(t) + h(t)
        }
        
        if (find_index(Ti, uniquet_cens) != 1){
         print(777);
         print(Ti);
         print(find_index(Ti, uniquet_cens));
         target += -gauss_kronrod_quad(locat, weights, Ti, uniquet_cens, bSpline_basis_t_cens, coefficients, x_cens, Beta);  // at log scale,  right censored data log(S(t)),  log(S(t)) = -H(t)
        }
        
      }
      }
    "
    }
    # compile the model
    bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
    
    # Model fitting and summary
    bayesian_model_fit <- suppressWarnings(
      sampling(
        bayesian_model,
        data = stan_data_basline,
        iter = niter,
        warmup = nwarmup,
        thin = 10,
        chain = 1
      )
    )
    
    # Summary of the fit
    output <- summary(bayesian_model_fit)$summary
    return(output)
  }
}

stan_data_basline <- list(
  N = stan_data$N,
  t = stan_data$t,
  N_cens = stan_data$N_cens,
  t_cens = stan_data$t_cens,
  K = stan_data$K,
  x = stan_data$x,
  x_cens = stan_data$x_cens, # # Ensure Beta is a vector of length 1
  Beta = array(0.5, dim = c(1)),
  covariate = stan_data$covariate,
  obstime = stan_data$obstime,
  status = stan_data$status
)

Output3 <- Bayesian_Survival_baseline(stan_data = stan_data_basline, assumption = "bSplines") #exponential, weibull,  bSplines
print(Output3)
```

```{r, echo=TRUE}
stan_data_kidney_basline <- list(
  N = sum(df_using$status2 == 1),
  t = df_using$time[df_using$status2 == 1],
  N_cens = sum(df_using$status2 == 0),
  t_cens = runif(sum(df_using$status2 == 0), 3, 6),
  K = 3,
  x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
  x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
  Beta = c(-1.29, 3.48e-03, 1.97e-02),
  covariate = Design_matrix,
  obstime = df_using$time,
  status = df_using$status2
)

Output3 <- Bayesian_Survival_baseline(stan_data = stan_data_kidney_basline, assumption = "bSplines") 
print(Output3)
```

# STEP 4: Do this on the kidney transplant real-world data
```{r, echo=TRUE}
df <- readRDS("./preprocessed_NOTR_DGF.rds")
df_using <- df[, c("Recipientsex", "Donorage", "time", "status")]
df_using$status2 <- ifelse(df_using$status == "graftloss", 1, 0)

# print(sum(!complete.cases(df_using)))
# df_using <- df_using[complete.cases(df_using),]
Design_matrix = model.matrix(~ Recipientsex*Donorage, data = df_using)
stan_data_kidney <- list(
  N = sum(df_using$status2 == 1),
  t = df_using$time[df_using$status2 == 1],
  N_cens = sum(df_using$status2 == 0),
  t_cens = runif(sum(df_using$status2 == 0), 3, 6),
  K = 3,
  x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
  x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
  covariate = Design_matrix,
  obstime = df_using$time,
  status = df_using$status2
)

Output2 <- Bayesian_Survival_PH(stan_data = stan_data_kidney) 
print(Output2)
```

## STEP 4.2: Extract the prediction
```{r, echo=TRUE}
# Based on predictive power for survival models
install.packages("Hmisc")
library(Hmisc)

# Example data
time <- c(5, 8, 12, 15, 20)
status <- c(1, 0, 1, 1, 0)
predicted <- c(0.2, 0.4, 0.6, 0.8, 0.3)

# Calculate Somers' D
result <- rcorr.cens(predicted, Surv(time, status))
print(result)
```
