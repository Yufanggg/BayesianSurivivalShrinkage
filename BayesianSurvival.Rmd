---
title: "BayesianSurvival"
author: "Yufang"
date: "2025-02-19"
output: pdf_document
---

# STEP 1. load packages
```{r, echo=TRUE}
rm(list = ls())
# install.packages("rstan")
# install.packages("readr")
library(rstan)
library(readr)
library(survival)
library(splines2)
# Set seed for reproducibility
set.seed(42)
source("./SurvivalDataGenerator.R")
```

# STEP 2. predefine a design matrix with one column 
```{r, echo=TRUE}
n_samples = 1000
Betas = 1
Design_matrix = as.matrix(rbinom(n_samples, 1, prob = 0.5)) #rnorm(n_samples))
BaselinePara = c(0.1, 0.2)


stan_data = SurvivalDataGenerator(n_samples, Betas, Design_matrix, 
                                  BaselinePara, BaselineDistr = "weibull") # exponential, weibull, and Gompertz

# use the traditional coxph to verify that the data was correctly generated
coxph(Surv(stan_data$obstime, stan_data$status) ~ stan_data$covariate)
```
## Conclusion for STEP 2: the betas are correctly estimated via traditional cox regression, meaning that data was correctly generated.

# STEP 3. Semiparametric & Parametric Bayesian survival model
```{r, echo=TRUE}
Bayesian_Survival_PH <- function(stan_data,
                              niter = 10000,
                              nwarmup = 1000,
                              thin = 10,
                              chains = 1) {
  # Proportional Hazard (PH) Model with covariates via partial likelihood function
  code_bayesian_model <- "
    data {
      int <lower=0> K; //num covariates
      int <lower=0> N; // num uncensored obs

      matrix[N, K] x; // covariates for uncensored obs

      int N_cens; // num censored obs
      matrix[N_cens, K] x_cens; // covariates for censored obs
  }
  parameters {
    vector[K] beta; // slopes without intercept
  }
  model {
    beta ~ normal(0, 2); // prior
    vector[N] log_theta = x * beta;
    vector [N_cens] log_theta_c = x_cens * beta;
    real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
    target += log_theta - log_denom;

  }
"
  
  
  # compile the model
  bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
  
  # Model fitting and summary
  bayesian_model_fit <- suppressWarnings(
    sampling(
      bayesian_model,
      data = stan_data,
      iter = niter,
      warmup = nwarmup,
      thin = 10,
      chain = 1
    )
  )
  
  # Summary of the fit
  output <- summary(bayesian_model_fit)$summary
  return(output)
  
}

Output <- Bayesian_Survival_PH(stan_data = stan_data) # The weibull and Gompertz simulation was not correctly implemented yet.
print(Output)
```
## Conclusion for STEP 3: the betas are correctly estimated via bayesian cox regression, meaning that bayesian cox regression was correctly defined.

## STEP 4.1: estimate the baseline function
```{r, echo=TRUE}
# Exponential baseline distribution from a bayesian perspective
Bayesian_Survival_baseline <- function(stan_data, assumption = "exponential", school = "Bayesian", 
                              niter = 10000, 
                              nwarmup = 1000,
                              thin = 10,
                              chains = 1) {
  if (school == "Bayesian") {
    if (assumption == "exponential") {
      code_bayesian_model <- "
    data {
      int <lower=0> K; //num covariates
      int <lower=0> N; // num uncensored obs

      vector[N] t; // event time (non-strict decreasing)
      matrix[N, K] x; // covariates for uncensored obs

      int N_cens; // num censored obs
      vector[N_cens] t_cens; // censoring time
      matrix[N_cens, K] x_cens; // covariates for censored obs

      vector[K] Beta; // estimated coefficients from PH model
    }

    parameters {
    real<lower = 0> lambda; // parameters in expoential assumption
    }
    model {
    // prior
    lambda ~ lognormal(0, 1);

    // log-likelihood, represented by [target]

    target += exponential_lpdf(t | lambda * exp(x*Beta)); // uncensored data log(f(t))

    target += exponential_lccdf(t_cens | lambda * exp(x*Beta)); // right censored data log(S(t))

    // target + = exponential_lpdf(t | lambda * exp(x * beta)) // the same with  t ~ exponential(lambda * exp(x*Beta));
    // target += exponential_lccdf(t_cens | lambda * exp(x_cens * Beta));

    }
    "
    }
    
    else if (assumption == "weibull") {
      code_bayesian_model <- "
      data {
        int <lower=0> K; //num covariates
        int <lower=0> N; // num uncensored obs

        vector[N] t; // event time (non-strict decreasing)
        matrix[N, K] x; // covariates for uncensored obs

        int N_cens; // num censored obs
        vector[N_cens] t_cens; // censoring time
        matrix[N_cens, K] x_cens; // covariates for censored obs

        vector[K] Beta; // estimated coefficients from PH model
      }
      parameters {
        real<lower = 0> alpha; // parameters in weibull assumption
        real<lower = 0> sigma; // parameters in weibull assumption
       }
     model {
       // Priors
       alpha ~ lognormal(0, 1);
       sigma ~ lognormal(0, 1);

       // log-likelihood, represented by [target]
       target += weibull_lpdf(t | alpha, sigma/exp(x*Beta/alpha)); // weibull_lpdf() is at log scale // uncensored data log(f(t))
       target += weibull_lccdf(t_cens | alpha, sigma/exp(x_cens*Beta/alpha)); // weibull_lccdf() is at log scale  // right censored data log(S(t)) //log complementary cumulative distribution function (log-CCDF) for an weibull distribution
  }
"
    }
    
    else if (assumption == "bSplines") {
      message("We utilized B-splines to estimate the baseline cumulative hazard function.")
      time_combined <- sort(unique(c(stan_data_basline$t, stan_data_basline$t_cens)))
      notes = seq(runif(5, min(time_combined), max(time_combined)))
      bSpline_basis <- bSpline(time_combined, knots = notes, degree = 3, intercept = FALSE) # The B-spline basis is calculated using the method implemented in the splines2 package

      # Compute the derivative of the B-spline basis
      bSpline_derivative <- deriv(bSpline_basis)
      
      # Out the corresponding information in stan data
      stan_data_basline$bSpline_basis <- bSpline_basis
      stan_data_basline$bSpline_derivative <- bSpline_derivative
      
      code_bayesian_model <- "
      data {
        int <lower=0> K; //num covariates
        int <lower=0> N; // num uncensored obs

        vector[N] t; // event time (non-strict decreasing)
        matrix[N, K] x; // covariates for uncensored obs

        int N_cens; // num censored obs
        vector[N_cens] t_cens; // censoring time
        matrix[N_cens, K] x_cens; // covariates for censored obs

        vector[K] Beta; // estimated coefficients from PH model
        
        matrix[N + N_cens, 8] bSpline_basis;
        matrix[N + N_cens, 8] bSpline_derivative;
      }
      
      parameters {
        vector[K] coefficients;
      } 
        
      model {
      // Priors
      for (i in 1:N){
        coefficients[i] ~ normal(0, 1);
      }
      
      // log-likelihood, represented by [target]
      target += (-bSpline_basis*coefficients * exp(x * Beta)) + x * Beta + log(coefficients) + log(bSpline_derivative) ; // uncensored data log(f(t)), -H(t) = -bSpline_basis*cofficients * exp(x * Beta)
        
      target += -bSpline_basis* coefficients * exp(x_cens * Beta);  // at log scale,  right censored data log(S(t)),  log(S(t)) = -H(t)
      }
    "
    }
    
    
    
    # compile the model
    bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
    
    # Model fitting and summary
    bayesian_model_fit <- suppressWarnings(
      sampling(
        bayesian_model,
        data = stan_data,
        iter = niter,
        warmup = nwarmup,
        thin = 10,
        chain = 1
      )
    )
    
    # Summary of the fit
    output <- summary(bayesian_model_fit)$summary
    return(output)
  }
}

stan_data_basline <- list(
  N = stan_data$N,
  t = stan_data$t,
  N_cens = stan_data$N_cens,
  t_cens = stan_data$t_cens,
  K = stan_data$K,
  x = stan_data$x,
  x_cens = stan_data$x_cens, # # Ensure Beta is a vector of length 1
  Beta = array(0.5, dim = c(1)),
  covariate = stan_data$covariate,
  obstime = stan_data$obstime,
  status = stan_data$status
)

Output3 <- Bayesian_Survival_baseline(stan_data = stan_data_basline, assumption = "bSplines") #exponential, weibull,  bSplines
print(Output3)
```

```{r, echo=TRUE}
stan_data_kidney_basline <- list(
  N = sum(df_using$status2 == 1),
  t = df_using$time[df_using$status2 == 1],
  N_cens = sum(df_using$status2 == 0),
  t_cens = runif(sum(df_using$status2 == 0), 3, 6),
  K = 3,
  x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
  x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
  Beta = c(-1.29, 3.48e-03, 1.97e-02),
  covariate = Design_matrix,
  obstime = df_using$time,
  status = df_using$status2
)

Output3 <- Bayesian_Survival_baseline(stan_data = stan_data_kidney_basline, assumption = "bSplines") 
print(Output3)
```

# STEP 4: Do this on the kidney transplant real-world data
```{r, echo=TRUE}
df <- readRDS("./preprocessed_NOTR_DGF.rds")
df_using <- df[, c("Recipientsex", "Donorage", "time", "status")]
df_using$status2 <- ifelse(df_using$status == "graftloss", 1, 0)

# print(sum(!complete.cases(df_using)))
# df_using <- df_using[complete.cases(df_using),]
Design_matrix = model.matrix(~ Recipientsex*Donorage, data = df_using)
stan_data_kidney <- list(
  N = sum(df_using$status2 == 1),
  t = df_using$time[df_using$status2 == 1],
  N_cens = sum(df_using$status2 == 0),
  t_cens = runif(sum(df_using$status2 == 0), 3, 6),
  K = 3,
  x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
  x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
  covariate = Design_matrix,
  obstime = df_using$time,
  status = df_using$status2
)

Output2 <- Bayesian_Survival_PH(stan_data = stan_data_kidney) 
print(Output2)
```

## STEP 4.2: Extract the prediction
```{r, echo=TRUE}
# Based on predictive power for survival models
install.packages("Hmisc")
library(Hmisc)

# Example data
time <- c(5, 8, 12, 15, 20)
status <- c(1, 0, 1, 1, 0)
predicted <- c(0.2, 0.4, 0.6, 0.8, 0.3)

# Calculate Somers' D
result <- rcorr.cens(predicted, Surv(time, status))
print(result)
```
