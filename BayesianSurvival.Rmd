---
title: "BayesianSurvival"
author: "Yufang"
date: "2025-02-19"
output: pdf_document
---

# STEP 1. load packages
```{r, echo=TRUE}
rm(list = ls())
# install.packages("rstan")
# install.packages("readr")
library(rstan)
library(readr)
library(survival)
# Set seed for reproducibility
set.seed(42)
source("./SurvivalDataGenerator.R")
```

# STEP 2. predefine a design matrix with one column 
```{r, echo=TRUE}
n_samples = 1000
Betas = 1
Design_matrix = as.matrix(rbinom(n_samples, 1, prob = 0.5)) #rnorm(n_samples))
BaselinePara = c(0.1, 0.2)


stan_data = SurvivalDataGenerator(n_samples, Betas, Design_matrix, 
                                  BaselinePara, BaselineDistr = "weibull") # exponential, weibull, and Gompertz

# use the traditional coxph to verify that the data was correctly generated
coxph(Surv(stan_data$obstime, stan_data$status) ~ stan_data$covariate)
```
## Conclusion for STEP 2: the betas are correctly estimated via traditional cox regression, meaning that data was correctly generated.

# STEP 3. Semiparametric & Parametric Bayesian survival model
```{r, echo=TRUE}
Bayesian_Survival <- function(stan_data, baseline = "PH", niter = 10000, nwarmup = 1000, thin = 10, chains = 1) {
  if (baseline == "PH") {
    # Proportional Hazard (PH) Model with covariates via partial likelihood function
    code_bayesian_model <- "
    data {
      int <lower=0> K; //num covariates
      int <lower=0> N; // num uncensored obs

      vector[N] t; // event time (non-strict decreasing)
      matrix[N, K] x; // covariates for uncensored obs

      int N_cens; // num censored obs
      vector[N_cens] t_cens; // censoring time
      matrix[N_cens, K] x_cens; // covariates for censored obs
  }
  parameters {
    vector[K] beta; // slopes without intercept
  }
  model {
    beta ~ normal(0, 2); // prior
    vector[N] log_theta = x * beta;
    vector [N_cens] log_theta_c = x_cens * beta;
    real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
    target += log_theta - log_denom;

  }
"
  }
  
  else if (baseline == "exponential"){
    code_bayesian_model <- "
    data {
      int <lower=0> K; //num covariates
      int <lower=0> N; // num uncensored obs

      vector[N] t; // event time (non-strict decreasing)
      matrix[N, K] x; // covariates for uncensored obs

      int N_cens; // num censored obs
      vector[N_cens] t_cens; // censoring time
      matrix[N_cens, K] x_cens; // covariates for censored obs
  }
  parameters {
    real<lower=0> lambda; // baseline rate parameter
    vector[K] beta; // slopes without intercept
    
  }
  model {
    lambda ~ lognormal(0, 1); // prior
    beta ~ normal(0, 2); // prior
    t ~ exponential(lambda * exp(x * beta));
    // target += exponential_lpdf(t | lambda * exp(x * beta));
    target += exponential_lccdf(t_cens | lambda * exp(x_cens * beta)); //log complementary cumulative distribution function (log-CCDF) for an exponential distribution

  }
"
  }
  else if (baseline == "weibull") {
    code_bayesian_model <- "
    data {
      int <lower=0> K; //num covariates
      int <lower=0> N; // num uncensored obs

      vector[N] t; // event time (non-strict decreasing)
      matrix[N, K] x; // covariates for uncensored obs

      int N_cens; // num censored obs
      vector[N_cens] t_cens; // censoring time
      matrix[N_cens, K] x_cens; // covariates for censored obs
  }
  parameters {
    real<lower=0> shape; 
    real<lower=0> scale;
    vector[K] beta; // slopes without intercept
  }
  model {
    shape ~ lognormal(0, 1); // prior
    scale ~ lognormal(0, 1); // prior
    beta ~ normal(0, 2); // prior
    t ~ weibull(shape, scale / exp(x * beta)); 
    target += weibull_lccdf(t_cens | shape, scale/exp(x_cens * beta)); //log complementary cumulative distribution function (log-CCDF) for an weibull distribution

  }
"
  }
  
  else if (baseline == "Gompertz"){
    # pass
  }

  # compile the model
  bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
  
  # Model fitting and summary
  bayesian_model_fit <- suppressWarnings(sampling(bayesian_model, data = stan_data, iter = niter, warmup = nwarmup, thin = 10, chain = 1))
  
  # Summary of the fit
  output <- summary(bayesian_model_fit)$summary
  return(output)
  
}

Output <- Bayesian_Survival(stan_data = stan_data, baseline = "PH") # The weibull and Gompertz simulation was not correctly implemented yet.
print(Output)
```
## Conclusion for STEP 3: the betas are correctly estimated via bayesian cox regression, meaning that bayesian cox regression was correctly defined.

# STEP 4: Do this on the kidney transplant real-world data
```{r, echo=TRUE}
df <- readRDS("./preprocessed_NOTR_DGF.rds")
df_using <- df[, c("Recipientsex", "Donorage", "time", "status")]
df_using$status2 <- ifelse(df_using$status == "graftloss", 1, 0)

# print(sum(!complete.cases(df_using)))
# df_using <- df_using[complete.cases(df_using),]
Design_matrix = model.matrix(~ Recipientsex*Donorage, data = df_using)
stan_data_kidney <- list(
  N = sum(df_using$status2 == 1),
  t = df_using$time[df_using$status2 == 1],
  N_cens = sum(df_using$status2 == 0),
  t_cens = runif(sum(df_using$status2 == 0), 3, 6),
  K = 3,
  x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
  x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
  covariate = Design_matrix,
  obstime = df_using$time,
  status = df_using$status2
)

Output2 <- Bayesian_Survival(stan_data = stan_data_kidney, baseline = "PH") 
print(Output2)
```

## STEP 4.1: estimate the baseline function
```{r, echo=TRUE}

```

## STEP 4.2: Extract the prediction
```{r, echo=TRUE}
# Based on predictive power for survival models
install.packages("Hmisc")
library(Hmisc)

# Example data
time <- c(5, 8, 12, 15, 20)
status <- c(1, 0, 1, 1, 0)
predicted <- c(0.2, 0.4, 0.6, 0.8, 0.3)

# Calculate Somers' D
result <- rcorr.cens(predicted, Surv(time, status))
print(result)
```
