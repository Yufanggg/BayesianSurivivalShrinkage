---
title: "Generate_sim_data"
author: "Yufang Wang"
date: "2025-03-18"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
setwd("G:/MasterThesis/Code/")   # C:/Users/Alisa_Wang/Desktop/MasterThesis/Code/
source("./function_file//Functions.R") #function for data analysis
source("./function_file/DataPreprocessing.R")

install_and_load <- function(packages) {
  for (pkg in packages) {
    if (!require(pkg, character.only = TRUE)) {
      install.packages(pkg, dependencies = TRUE)
    }
    library(pkg, character.only = TRUE) }
  
}

# List of required packages
required_packages <- c("rstan", "rstantools", "coda", "readr", "survival", "splines2", "dplyr", "simsurv", "Hmisc", # packages for the original data analysis
                       
                       # packages for the real-world data preprocesssing
                       "readxl", "tidyverse", "survminer",  "lubridate", "modeest", "reshape2", "tableone", "tidytidbits",
                       "survivalAnalysis", "naniar", "transplantr", "ggeffects", "splitstackshape", "data.table", "lessR",
                       "tibble", "janitor", "mice", "ggthemes", "forestplot", "ggtext", "splines")
# Install and/or load packages
install_and_load(required_packages)
```


# reorganize the dataset 
```{r, echo=TRUE}
df_thei <- readRDS("./Data/NOTR_DGF.rds")#Data_proprocessing1()
df_reorganize <- Real_world_data_reorganization(df_thei)
head(df_reorganize)
```

# EDA
```{r, echo=TRUE}
# summarize of data to get the variable description
# Create a correlation matrix
cor_matrix <- cor(df_reorganize[, sapply(df_reorganize, is.numeric)])
library(corrplot)
# Plot the correlation matrix
corrplot(cor_matrix, method = "color", type = "upper", 
         tl.col = "black", tl.srt = 45, 
         addCoef.col = "black", number.cex = 0.7)

results2 <- data.frame(
  Variable = character(),
  mean_val = numeric(),
  medium_val = numeric(),
  sd_val = numeric()
)

library(ggplot2)
# Function to create bar plots for factor columns
create_barplot <- function(df, var) {
   ggplot(df, aes_string(x = var, fill = var)) +
    geom_bar() +
    labs(title = paste("Bar Plot of", var), x = var, y = "Proportion") +
    theme_minimal() +
    theme(legend.position = "bottom")
}

# Loop through each column in the data frame
for (var in colnames(df_reorganize)) {
  if (is.numeric(df_reorganize[[var]])){
    results2 <- rbind(results2, data.frame(
      Variable = var,
      mean_val = mean(df_reorganize[[var]]),
      median_val = median(df_reorganize[[var]]),
      sd_val =  sd(df_reorganize[[var]])
    ))
  } else if (!is.numeric(df_reorganize[[var]]) & !inherits(df_reorganize[[var]], "Date")) {
    print(create_barplot(df_reorganize, var))
  }
}

# Print the results data frame
print(results2)
```

## check fothe missing data of numeric variables
```{r, echo=TRUE}
results <- data.frame(
  Variable = character(),
  LengthUniqueValues = integer(),
  MissingObs = integer(),
  UniqueValues = character()
)

# Loop through each column in the data frame
for (var in colnames(df_reorganize)) {
  if (!is.numeric(df_reorganize[[var]]) & !inherits(df_reorganize[[var]], "Date")) {
    # Convert unique values to a single string
    unique_values_str <- paste(unique(df_reorganize[[var]]), collapse = ", ")
    
    # Add the variable name, unique values, and number of unique values to the results data frame
    results <- rbind(results, data.frame(
      Variable = var,
      LengthUniqueValues = length(unique(df_reorganize[[var]])),
      MissingObs = sum(is.na(df_reorganize[[var]])),
      UniqueValues = unique_values_str
    ))
  }
  
  else{
     results <- rbind(results, data.frame(
      Variable = var,
      LengthUniqueValues = length(unique(df_reorganize[[var]])),
      MissingObs = sum(is.na(df_reorganize[[var]])),
      UniqueValues = unique_values_str
    ))
  }
}

# Print the results data frame
print(results)

# joint non-complete cases
sum(!complete.cases(df_reorganize))
sum(complete.cases(df_reorganize))
```

```{r, echo=TRUE}

# recensoring data because of not accounting for completing risks: only focusing on graft loss
df_reorganize$status2 = ifelse(df_reorganize$status == "graftloss", 1, 0)


## deal with missing data issues
# set the missing InitialOnmachineindicator being an additional category
df_reorganize$InitialOnmachineindicator = if_else(is.na(df_reorganize$InitialOnmachineindicator), "Unknown", df_reorganize$InitialOnmachineindicator)

# set the datatype
df_reorganize[] <- lapply(df_reorganize, function(x) if(is.character(x)) as.factor(x) else x)

df_reorganize <- df_reorganize[, !(colnames(df_reorganize) %in% c("Dateoftransplant", "status2"))]
# impute the missing Smoking data
library(mice)
methods = make.method(df_reorganize)
methods["Smoking"] = "pmm" # Predictive mean matching
methods[setdiff(names(df_reorganize), "Smoking")] <- ""
# Perform the imputation with more iterations in parallel
imputed_df_using <- mice(df_reorganize, method = methods, m = 5, maxit = 100, seed = 500)
# imputed_df_using <- futuremice(df_using, method = methods, parallelseed = 1, m = 5, maxit = 100, seed = 500)

# Complete the dataset with the imputed values
completed_df_ <- complete(imputed_df_using)
print(completed_df_)
saveRDS(completed_df_, "imputed_NOTR_DGF.rds")
```
```

#Implemented the code in a Cross-validation way
```{r, echo=TRUE}
source("./stan_bSpline.R")
stan_data <- stan_bSpline_data_Constructer(training_dataset = sim_data, testing_dataset = sim_data, obs_window = 5)
model_fit <- Bayesian_Survival_model(stan_data = stan_data, baseline_assumption = "bSplines") # #exponential, weibull,  bSplines
#Bayesian_Survival_model_check(model_fit) # model diagnostic

#extract the info from the bayesian model fit
model_result <- Bayesian_Survival_result_Extract(bayesian_model_fit = model_fit)

ComparsionValues <- list(
  Beta_reference = c(beta, rep(0, 45)),
  test_t = sim_data$obstime,
  test_status = sim_data$status,
  Selection_reference =c(rep(TRUE, 10), rep(FALSE, 45))
)

Model_performance_eval(model_result, ComparsionValues)
```

# Implemented it in the bayesian code
```{r, echo=TRUE}
cross_validation(dataset = sim_data,
                 method = "exponential",
                 spilit = FALSE) {
  X <-
    model.matrix( ~ . ^ 2, data = dataset[,!(names(dataset) %in% c("id", "obstime", "status"))])
  dim(X)
  
  column_names = colnames(X)
  main_names =  column_names[!grepl(":", column_names) &
                               column_names != "(Intercept)"]
  X_main = X[, main_names]
  
  int_names =  column_names[grepl(":", column_names)]
  X_int = X[, int_names]
  
  p <- dim(X_main)[2]
  q <- dim(X_int)[2]
  
  main_indices_for_int = find_main_effect_indices(int_names, main_names)
  g1 <- g(main_indices_for_int, 1)
  g2 <- g(main_indices_for_int, 2)
  
  
  # Prepares data and parameter input for Stan.
  stan_data <- list(
    # response and time variable
    nevent = nrow(dataset[dataset$status == 1, ]),
    nrcens = nrow(dataset[dataset$status == 0, ]),
    t_event = dataset[dataset$status == 1, "obstime"],
    t_rcens = dataset[dataset$status == 0, "obstime"],
    
    # predictor matrices (time-fixed)
    p = p,
    q = q,
    x_event = X_main[dataset$status == 1,],
    x_int_event =  X_int[dataset$status == 1,],
    
    x_rcens = X_main[dataset$status == 0,],
    x_int_rcens = X_int[dataset$status == 0,],
    
    # link the interaction effect with the corresponding main effects
    g1 = g1,
    g2 = g2,
    
    # for prediction
    nnew = nrow(dataset),
    x_new = X_main,
    x_int_new = X_int,
    t_new = dataset[, "obstime"]
  )
  
  rm(dataset,
     X,
     X_int,
     X_main,
     p,
     q,
     g1,
     g2,
     int_names,
     main_names,
     column_names)
  
  # fit the model
  model <-
    Bayesian_Survival_includingbaseline(stan_data = stan_data, baseline_assumption = "bSplines") # #exponential, weibull,  bSplines
  return (model)
}
```