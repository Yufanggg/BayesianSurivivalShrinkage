Design_matrix = model.matrix(~ Recipientsex*Donorage, data = df_using)
stan_data_kidney <- list(
N = sum(df_using$status2 == 1),
t = df_using$time[df_using$status2 == 1],
N_cens = sum(df_using$status2 == 0),
t_cens = runif(sum(df_using$status2 == 0), 3, 6),
K = 3,
x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
covariate = Design_matrix,
obstime = df_using$time,
status = df_using$status2
)
Output2 <- Bayesian_Survival(stan_data = stan_data_kidney, baseline = "PH")
print(Output2)
Bayesian_Survival <- function(stan_data,
niter = 10000,
nwarmup = 1000,
thin = 10,
chains = 1) {
# Proportional Hazard (PH) Model with covariates via partial likelihood function
code_bayesian_model <- "
data {
int <lower=0> K; //num covariates
int <lower=0> N; // num uncensored obs
vector[N] t; // event time (non-strict decreasing)
matrix[N, K] x; // covariates for uncensored obs
int N_cens; // num censored obs
vector[N_cens] t_cens; // censoring time
matrix[N_cens, K] x_cens; // covariates for censored obs
}
parameters {
vector[K] beta; // slopes without intercept
}
model {
beta ~ normal(0, 2); // prior
vector[N] log_theta = x * beta;
vector [N_cens] log_theta_c = x_cens * beta;
real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
target += log_theta - log_denom;
}
"
# compile the model
bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
# Model fitting and summary
bayesian_model_fit <- suppressWarnings(
sampling(
bayesian_model,
data = stan_data,
iter = niter,
warmup = nwarmup,
thin = 10,
chain = 1
)
)
# Summary of the fit
output <- summary(bayesian_model_fit)$summary
return(output)
}
Output <- Bayesian_Survival(stan_data = stan_data, baseline = "PH") # The weibull and Gompertz simulation was not correctly implemented yet.
Bayesian_Survival <- function(stan_data,
niter = 10000,
nwarmup = 1000,
thin = 10,
chains = 1) {
# Proportional Hazard (PH) Model with covariates via partial likelihood function
code_bayesian_model <- "
data {
int <lower=0> K; //num covariates
int <lower=0> N; // num uncensored obs
vector[N] t; // event time (non-strict decreasing)
matrix[N, K] x; // covariates for uncensored obs
int N_cens; // num censored obs
vector[N_cens] t_cens; // censoring time
matrix[N_cens, K] x_cens; // covariates for censored obs
}
parameters {
vector[K] beta; // slopes without intercept
}
model {
beta ~ normal(0, 2); // prior
vector[N] log_theta = x * beta;
vector [N_cens] log_theta_c = x_cens * beta;
real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
target += log_theta - log_denom;
}
"
# compile the model
bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
# Model fitting and summary
bayesian_model_fit <- suppressWarnings(
sampling(
bayesian_model,
data = stan_data,
iter = niter,
warmup = nwarmup,
thin = 10,
chain = 1
)
)
# Summary of the fit
output <- summary(bayesian_model_fit)$summary
return(output)
}
Output <- Bayesian_Survival(stan_data = stan_data) # The weibull and Gompertz simulation was not correctly implemented yet.
print(Output)
df <- readRDS("./preprocessed_NOTR_DGF.rds")
df_using <- df[, c("Recipientsex", "Donorage", "time", "status")]
df_using$status2 <- ifelse(df_using$status == "graftloss", 1, 0)
# print(sum(!complete.cases(df_using)))
# df_using <- df_using[complete.cases(df_using),]
Design_matrix = model.matrix(~ Recipientsex*Donorage, data = df_using)
stan_data_kidney <- list(
N = sum(df_using$status2 == 1),
t = df_using$time[df_using$status2 == 1],
N_cens = sum(df_using$status2 == 0),
t_cens = runif(sum(df_using$status2 == 0), 3, 6),
K = 3,
x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
covariate = Design_matrix,
obstime = df_using$time,
status = df_using$status2
)
Output2 <- Bayesian_Survival_PH(stan_data = stan_data_kidney)
rm(list = ls())
# install.packages("rstan")
# install.packages("readr")
library(rstan)
library(readr)
library(survival)
# Set seed for reproducibility
set.seed(42)
source("./SurvivalDataGenerator.R")
n_samples = 1000
Betas = 1
Design_matrix = as.matrix(rbinom(n_samples, 1, prob = 0.5)) #rnorm(n_samples))
BaselinePara = c(0.1, 0.2)
stan_data = SurvivalDataGenerator(n_samples, Betas, Design_matrix,
BaselinePara, BaselineDistr = "weibull") # exponential, weibull, and Gompertz
# use the traditional coxph to verify that the data was correctly generated
coxph(Surv(stan_data$obstime, stan_data$status) ~ stan_data$covariate)
Bayesian_Survival_PH <- function(stan_data,
niter = 10000,
nwarmup = 1000,
thin = 10,
chains = 1) {
# Proportional Hazard (PH) Model with covariates via partial likelihood function
code_bayesian_model <- "
data {
int <lower=0> K; //num covariates
int <lower=0> N; // num uncensored obs
vector[N] t; // event time (non-strict decreasing)
matrix[N, K] x; // covariates for uncensored obs
int N_cens; // num censored obs
vector[N_cens] t_cens; // censoring time
matrix[N_cens, K] x_cens; // covariates for censored obs
}
parameters {
vector[K] beta; // slopes without intercept
}
model {
beta ~ normal(0, 2); // prior
vector[N] log_theta = x * beta;
vector [N_cens] log_theta_c = x_cens * beta;
real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
target += log_theta - log_denom;
}
"
# compile the model
bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
# Model fitting and summary
bayesian_model_fit <- suppressWarnings(
sampling(
bayesian_model,
data = stan_data,
iter = niter,
warmup = nwarmup,
thin = 10,
chain = 1
)
)
# Summary of the fit
output <- summary(bayesian_model_fit)$summary
return(output)
}
Output <- Bayesian_Survival_PH(stan_data = stan_data) # The weibull and Gompertz simulation was not correctly implemented yet.
print(Output)
df <- readRDS("./preprocessed_NOTR_DGF.rds")
df_using <- df[, c("Recipientsex", "Donorage", "time", "status")]
df_using$status2 <- ifelse(df_using$status == "graftloss", 1, 0)
# print(sum(!complete.cases(df_using)))
# df_using <- df_using[complete.cases(df_using),]
Design_matrix = model.matrix(~ Recipientsex*Donorage, data = df_using)
stan_data_kidney <- list(
N = sum(df_using$status2 == 1),
t = df_using$time[df_using$status2 == 1],
N_cens = sum(df_using$status2 == 0),
t_cens = runif(sum(df_using$status2 == 0), 3, 6),
K = 3,
x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
covariate = Design_matrix,
obstime = df_using$time,
status = df_using$status2
)
Output2 <- Bayesian_Survival_PH(stan_data = stan_data_kidney)
print(Output2)
# Exponential baseline distribution from a bayesian perspective
Bayesian_Survival_baseline <- function(stan_data, assumption = "exponential",
niter = 10000,
nwarmup = 1000,
thin = 10,
chains = 1) {
if (assumption == "exponential"){
code_bayesian_model <- "
data {
int <lower=0> K; //num covariates
int <lower=0> N; // num uncensored obs
vector[N] t; // event time (non-strict decreasing)
matrix[N, K] x; // covariates for uncensored obs
int N_cens; // num censored obs
vector[N_cens] t_cens; // censoring time
matrix[N_cens, K] x_cens; // covariates for censored obs
vector[K] Beta; // estimated coefficients from PH model
}
parameters {
real<lower = 0> lambda; // parameters in expoential assumption
}
model {
lambda ~ lognormal(0, 1);; // prior
t ~ exponential(lambda * exp(x*Beta));
target += N_cens * exponential_lccdf(t_cens | lambda ( exp(x_cens * Beta)));
}
"
}
else if (assumption == "weibull") {
code_bayesian_model <- "
data {
int <lower=0> K; //num covariates
int <lower=0> N; // num uncensored obs
vector[N] t; // event time (non-strict decreasing)
matrix[N, K] x; // covariates for uncensored obs
int N_cens; // num censored obs
vector[N_cens] t_cens; // censoring time
matrix[N_cens, K] x_cens; // covariates for censored obs
}
parameters {
real<lower = 0> lambda; // parameters in expoential assumption
}
model {
lambda ~ lognormal(0, 1);; // prior
t ~ exponential(lambda);
target += N_cens * exponential_lccdf(t_cens | lambda);
}
"
}
else {
message("We utilized B-splines to estimate the baseline cumulative hazard function.")
}
# compile the model
bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
# Model fitting and summary
bayesian_model_fit <- suppressWarnings(
sampling(
bayesian_model,
data = stan_data,
iter = niter,
warmup = nwarmup,
thin = 10,
chain = 1
)
)
# Summary of the fit
output <- summary(bayesian_model_fit)$summary
return(output)
}
stan_data_kidney_basline <- list(
N = sum(df_using$status2 == 1),
t = df_using$time[df_using$status2 == 1],
N_cens = sum(df_using$status2 == 0),
t_cens = runif(sum(df_using$status2 == 0), 3, 6),
K = 3,
x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
Beta = c(-1.29, 3.48e-03, 1.97e-02),
covariate = Design_matrix,
obstime = df_using$time,
status = df_using$status2
)
Output3 <- Bayesian_Survival_baseline(stan_data = stan_data_kidney_basline)
# Exponential baseline distribution from a bayesian perspective
Bayesian_Survival_baseline <- function(stan_data, assumption = "exponential",
niter = 10000,
nwarmup = 1000,
thin = 10,
chains = 1) {
if (assumption == "exponential"){
code_bayesian_model <- "
data {
int <lower=0> K; //num covariates
int <lower=0> N; // num uncensored obs
vector[N] t; // event time (non-strict decreasing)
matrix[N, K] x; // covariates for uncensored obs
int N_cens; // num censored obs
vector[N_cens] t_cens; // censoring time
matrix[N_cens, K] x_cens; // covariates for censored obs
vector[K] Beta; // estimated coefficients from PH model
}
parameters {
real<lower = 0> lambda; // parameters in expoential assumption
}
model {
lambda ~ lognormal(0, 1);; // prior
t ~ exponential(lambda * exp(x*Beta));
target += N_cens * exponential_lccdf(t_cens | lambda * exp(x_cens * Beta));
}
"
}
else if (assumption == "weibull") {
code_bayesian_model <- "
data {
int <lower=0> K; //num covariates
int <lower=0> N; // num uncensored obs
vector[N] t; // event time (non-strict decreasing)
matrix[N, K] x; // covariates for uncensored obs
int N_cens; // num censored obs
vector[N_cens] t_cens; // censoring time
matrix[N_cens, K] x_cens; // covariates for censored obs
}
parameters {
real<lower = 0> lambda; // parameters in expoential assumption
}
model {
lambda ~ lognormal(0, 1);; // prior
t ~ exponential(lambda);
target += N_cens * exponential_lccdf(t_cens | lambda);
}
"
}
else {
message("We utilized B-splines to estimate the baseline cumulative hazard function.")
}
# compile the model
bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
# Model fitting and summary
bayesian_model_fit <- suppressWarnings(
sampling(
bayesian_model,
data = stan_data,
iter = niter,
warmup = nwarmup,
thin = 10,
chain = 1
)
)
# Summary of the fit
output <- summary(bayesian_model_fit)$summary
return(output)
}
stan_data_kidney_basline <- list(
N = sum(df_using$status2 == 1),
t = df_using$time[df_using$status2 == 1],
N_cens = sum(df_using$status2 == 0),
t_cens = runif(sum(df_using$status2 == 0), 3, 6),
K = 3,
x = as.matrix(Design_matrix[df_using$status2 == 1,-1]),
x_cens = as.matrix(Design_matrix[df_using$status2 == 0,-1]),
Beta = c(-1.29, 3.48e-03, 1.97e-02),
covariate = Design_matrix,
obstime = df_using$time,
status = df_using$status2
)
Output3 <- Bayesian_Survival_baseline(stan_data = stan_data_kidney_basline)
print(Output3)
install.packages("splines")
rm(list = ls())
library(dplyr)
library(survival)
library(mstate)
library(ggplot2)
library(corrplot)
setwd("G:/MasterThesis/Code" )
rm(list = ls())
library(dplyr)
df_using <- readRDS("./preprocessed_NOTR_DGF.rds")
# Create a correlation matrix
cor_matrix <- cor(df_using[, sapply(df_using, is.numeric)])
library(corrplot)
# Plot the correlation matrix
corrplot(cor_matrix, method = "color", type = "upper",
tl.col = "black", tl.srt = 45,
addCoef.col = "black", number.cex = 0.7)
results2 <- data.frame(
Variable = character(),
mean_val = numeric(),
medium_val = numeric(),
sd_val = numeric()
)
library(ggplot2)
# Function to create bar plots for factor columns
create_barplot <- function(df, var) {
ggplot(df, aes_string(x = var, fill = var)) +
geom_bar() +
labs(title = paste("Bar Plot of", var), x = var, y = "Proportion") +
theme_minimal() +
theme(legend.position = "bottom")
}
# Loop through each column in the data frame
for (var in colnames(df_using)) {
if (is.numeric(df_using[[var]])){
results2 <- rbind(results2, data.frame(
Variable = var,
mean_val = mean(df_using[[var]]),
median_val = median(df_using[[var]]),
sd_val =  sd(df_using[[var]])
))
} else if (!is.numeric(df_using[[var]]) & !inherits(df_using[[var]], "Date")) {
print(create_barplot(df_using, var))
}
}
# Print the results data frame
print(results2)
results <- data.frame(
Variable = character(),
LengthUniqueValues = integer(),
MissingObs = integer(),
UniqueValues = character()
)
# Loop through each column in the data frame
for (var in colnames(df_using)) {
if (!is.numeric(df_using[[var]]) & !inherits(df_using[[var]], "Date")) {
# Convert unique values to a single string
unique_values_str <- paste(unique(df_using[[var]]), collapse = ", ")
# Add the variable name, unique values, and number of unique values to the results data frame
results <- rbind(results, data.frame(
Variable = var,
LengthUniqueValues = length(unique(df_using[[var]])),
MissingObs = sum(is.na(df_using[[var]])),
UniqueValues = unique_values_str
))
}
else{
results <- rbind(results, data.frame(
Variable = var,
LengthUniqueValues = length(unique(df_using[[var]])),
MissingObs = sum(is.na(df_using[[var]])),
UniqueValues = unique_values_str
))
}
}
rm(list = ls())
# install.packages("rstan")
# install.packages("readr")
library(rstan)
library(readr)
library(survival)
# Set seed for reproducibility
set.seed(42)
source("./SurvivalDataGenerator.R")
n_samples = 1000
Betas = 1
Design_matrix = as.matrix(rbinom(n_samples, 1, prob = 0.5)) #rnorm(n_samples))
BaselinePara = c(0.1, 0.2)
stan_data = SurvivalDataGenerator(n_samples, Betas, Design_matrix,
BaselinePara, BaselineDistr = "weibull") # exponential, weibull, and Gompertz
# use the traditional coxph to verify that the data was correctly generated
coxph(Surv(stan_data$obstime, stan_data$status) ~ stan_data$covariate)
Bayesian_Survival_PH <- function(stan_data,
niter = 10000,
nwarmup = 1000,
thin = 10,
chains = 1) {
# Proportional Hazard (PH) Model with covariates via partial likelihood function
code_bayesian_model <- "
data {
int <lower=0> K; //num covariates
int <lower=0> N; // num uncensored obs
matrix[N, K] x; // covariates for uncensored obs
int N_cens; // num censored obs
matrix[N_cens, K] x_cens; // covariates for censored obs
}
parameters {
vector[K] beta; // slopes without intercept
}
model {
beta ~ normal(0, 2); // prior
vector[N] log_theta = x * beta;
vector [N_cens] log_theta_c = x_cens * beta;
real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
target += log_theta - log_denom;
}
"
# compile the model
bayesian_model <- stan_model(model_name = "bayesian_model", model_code = code_bayesian_model)
# Model fitting and summary
bayesian_model_fit <- suppressWarnings(
sampling(
bayesian_model,
data = stan_data,
iter = niter,
warmup = nwarmup,
thin = 10,
chain = 1
)
)
# Summary of the fit
output <- summary(bayesian_model_fit)$summary
return(output)
}
Output <- Bayesian_Survival_PH(stan_data = stan_data) # The weibull and Gompertz simulation was not correctly implemented yet.
print(Output)
